use crate::u24::u24;

use std::ops::Coroutine;

// A device (e.g. CPU, SMP, PPU) runs as a coroutine which can yield for various reasons.
// When a device yields, it reports the amount of time (in its own time-units) it has been running.
// The scheduler keeps track of each processor's relative progress, using that to respond to
// inter-processor sync-yields.
pub trait DeviceCoroutine = Coroutine<Yield = YieldTicks, Return = !>;
pub type YieldTicks = (YieldReason, u64);
// Particular functions of a device (e.g. a CPU instruction) may produce yields (e.g. a sync before
// accessing a shared register). Device functions are therefore coroutines which may trigger a yield.
// It's up to each device to plumb the yields and tick progress up to the scheduler via the DeviceCoroutine
// (see yield_all!())
pub trait Yieldable<T> = Coroutine<Yield = YieldReason, Return = T>;
pub trait InstructionCoroutine = Yieldable<()>;
pub type BoxGen = Box<dyn Unpin + DeviceCoroutine>;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Device {
    CPU,
    PPU,
    SMP,
}

#[derive(Clone, Copy, Debug)]
pub enum YieldReason {
    Sync(Device),
    FinishedInstruction(Device),
    Debug(DebugPoint),
    FrameReady,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum AccessType {
    Read,
    Write,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Access {
    pub access_type: AccessType,
    pub addr: u24,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DebugPoint {
    CodeBreakpoint,
    UnimplementedAccess(Access),
    // TODO: Should these be per-device?
    Breakpoint,
    StartedInterrupt,
    FinishedInterrupt,
}

// Re-issue all yields generated by $gen_expr, ultimately evaluating to its return value.
// This seems to have non-trivial overhead; ideally, it would behave like pasting the
// inner generator's code (yields included) into the caller. This codebase uses macros
// in some places to reduce both code duplication and generator dispatch costs.
macro_rules! yield_all {
    ($gen_expr:expr) => {{
        let mut generator = $gen_expr;
        loop {
            match Pin::new(&mut generator).resume(()) {
                CoroutineState::Yielded(yield_reason) => yield yield_reason,
                CoroutineState::Complete(out) => break out,
            }
        }
    }};
}
pub(crate) use yield_all;

// Run the generator until it is exhausted, discarding yields.
macro_rules! ignore_yields {
    ($gen_expr:expr) => {{
        let mut generator = $gen_expr;
        loop {
            match Pin::new(&mut generator).resume(()) {
                CoroutineState::Complete(out) => break out,
                _ => {}
            }
        }
    }};
}
pub(crate) use ignore_yields;
